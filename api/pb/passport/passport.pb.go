// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: passport.proto

package passport

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MFAResponse_MFAType int32

const (
	MFAResponse_TOTP MFAResponse_MFAType = 0
	MFAResponse_FIDO MFAResponse_MFAType = 1
	MFAResponse_SMS  MFAResponse_MFAType = 2
)

var MFAResponse_MFAType_name = map[int32]string{
	0: "TOTP",
	1: "FIDO",
	2: "SMS",
}

var MFAResponse_MFAType_value = map[string]int32{
	"TOTP": 0,
	"FIDO": 1,
	"SMS":  2,
}

func (x MFAResponse_MFAType) String() string {
	return proto.EnumName(MFAResponse_MFAType_name, int32(x))
}

func (MFAResponse_MFAType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{8, 0}
}

type Tokens struct {
	Token         string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	TokenExpire   int64  `protobuf:"varint,2,opt,name=tokenExpire,proto3" json:"tokenExpire,omitempty"`
	RefreshToken  string `protobuf:"bytes,3,opt,name=refreshToken,proto3" json:"refreshToken,omitempty"`
	RefreshExpire int64  `protobuf:"varint,4,opt,name=refreshExpire,proto3" json:"refreshExpire,omitempty"`
}

func (m *Tokens) Reset()         { *m = Tokens{} }
func (m *Tokens) String() string { return proto.CompactTextString(m) }
func (*Tokens) ProtoMessage()    {}
func (*Tokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{0}
}
func (m *Tokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tokens.Merge(m, src)
}
func (m *Tokens) XXX_Size() int {
	return m.Size()
}
func (m *Tokens) XXX_DiscardUnknown() {
	xxx_messageInfo_Tokens.DiscardUnknown(m)
}

var xxx_messageInfo_Tokens proto.InternalMessageInfo

func (m *Tokens) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *Tokens) GetTokenExpire() int64 {
	if m != nil {
		return m.TokenExpire
	}
	return 0
}

func (m *Tokens) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *Tokens) GetRefreshExpire() int64 {
	if m != nil {
		return m.RefreshExpire
	}
	return 0
}

type VerifyTokenRequest struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *VerifyTokenRequest) Reset()         { *m = VerifyTokenRequest{} }
func (m *VerifyTokenRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyTokenRequest) ProtoMessage()    {}
func (*VerifyTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{1}
}
func (m *VerifyTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyTokenRequest.Merge(m, src)
}
func (m *VerifyTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyTokenRequest proto.InternalMessageInfo

func (m *VerifyTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type VerifyTokenResponse struct {
	Valid         bool  `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Revoked       bool  `protobuf:"varint,2,opt,name=revoked,proto3" json:"revoked,omitempty"`
	TokenExpire   int64 `protobuf:"varint,3,opt,name=tokenExpire,proto3" json:"tokenExpire,omitempty"`
	RefreshExpire int64 `protobuf:"varint,4,opt,name=refreshExpire,proto3" json:"refreshExpire,omitempty"`
}

func (m *VerifyTokenResponse) Reset()         { *m = VerifyTokenResponse{} }
func (m *VerifyTokenResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyTokenResponse) ProtoMessage()    {}
func (*VerifyTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{2}
}
func (m *VerifyTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyTokenResponse.Merge(m, src)
}
func (m *VerifyTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyTokenResponse proto.InternalMessageInfo

func (m *VerifyTokenResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerifyTokenResponse) GetRevoked() bool {
	if m != nil {
		return m.Revoked
	}
	return false
}

func (m *VerifyTokenResponse) GetTokenExpire() int64 {
	if m != nil {
		return m.TokenExpire
	}
	return 0
}

func (m *VerifyTokenResponse) GetRefreshExpire() int64 {
	if m != nil {
		return m.RefreshExpire
	}
	return 0
}

type UserCreds struct {
	Username      string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	MFA           string `protobuf:"bytes,3,opt,name=MFA,proto3" json:"MFA,omitempty"`
	DevFP         string `protobuf:"bytes,4,opt,name=devFP,proto3" json:"devFP,omitempty"`
	InsecureLogin bool   `protobuf:"varint,5,opt,name=insecureLogin,proto3" json:"insecureLogin,omitempty"`
	Recaptcha     string `protobuf:"bytes,6,opt,name=recaptcha,proto3" json:"recaptcha,omitempty"`
	Next          bool   `protobuf:"varint,7,opt,name=next,proto3" json:"next,omitempty"`
}

func (m *UserCreds) Reset()         { *m = UserCreds{} }
func (m *UserCreds) String() string { return proto.CompactTextString(m) }
func (*UserCreds) ProtoMessage()    {}
func (*UserCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{3}
}
func (m *UserCreds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserCreds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCreds.Merge(m, src)
}
func (m *UserCreds) XXX_Size() int {
	return m.Size()
}
func (m *UserCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCreds.DiscardUnknown(m)
}

var xxx_messageInfo_UserCreds proto.InternalMessageInfo

func (m *UserCreds) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCreds) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserCreds) GetMFA() string {
	if m != nil {
		return m.MFA
	}
	return ""
}

func (m *UserCreds) GetDevFP() string {
	if m != nil {
		return m.DevFP
	}
	return ""
}

func (m *UserCreds) GetInsecureLogin() bool {
	if m != nil {
		return m.InsecureLogin
	}
	return false
}

func (m *UserCreds) GetRecaptcha() string {
	if m != nil {
		return m.Recaptcha
	}
	return ""
}

func (m *UserCreds) GetNext() bool {
	if m != nil {
		return m.Next
	}
	return false
}

type OAuthClientSecretCreds struct {
	Key    string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Secret string   `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	Scopes []string `protobuf:"bytes,3,rep,name=scopes,proto3" json:"scopes,omitempty"`
}

func (m *OAuthClientSecretCreds) Reset()         { *m = OAuthClientSecretCreds{} }
func (m *OAuthClientSecretCreds) String() string { return proto.CompactTextString(m) }
func (*OAuthClientSecretCreds) ProtoMessage()    {}
func (*OAuthClientSecretCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{4}
}
func (m *OAuthClientSecretCreds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OAuthClientSecretCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OAuthClientSecretCreds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OAuthClientSecretCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OAuthClientSecretCreds.Merge(m, src)
}
func (m *OAuthClientSecretCreds) XXX_Size() int {
	return m.Size()
}
func (m *OAuthClientSecretCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_OAuthClientSecretCreds.DiscardUnknown(m)
}

var xxx_messageInfo_OAuthClientSecretCreds proto.InternalMessageInfo

func (m *OAuthClientSecretCreds) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *OAuthClientSecretCreds) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *OAuthClientSecretCreds) GetScopes() []string {
	if m != nil {
		return m.Scopes
	}
	return nil
}

type OAuthCodeCreds struct {
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *OAuthCodeCreds) Reset()         { *m = OAuthCodeCreds{} }
func (m *OAuthCodeCreds) String() string { return proto.CompactTextString(m) }
func (*OAuthCodeCreds) ProtoMessage()    {}
func (*OAuthCodeCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{5}
}
func (m *OAuthCodeCreds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OAuthCodeCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OAuthCodeCreds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OAuthCodeCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OAuthCodeCreds.Merge(m, src)
}
func (m *OAuthCodeCreds) XXX_Size() int {
	return m.Size()
}
func (m *OAuthCodeCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_OAuthCodeCreds.DiscardUnknown(m)
}

var xxx_messageInfo_OAuthCodeCreds proto.InternalMessageInfo

func (m *OAuthCodeCreds) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type AuthRequest struct {
	// Types that are valid to be assigned to Creds:
	//	*AuthRequest_UserCreds
	//	*AuthRequest_OauthClientSecretCreds
	//	*AuthRequest_OAuthCodeCreds
	Creds isAuthRequest_Creds `protobuf_oneof:"creds"`
}

func (m *AuthRequest) Reset()         { *m = AuthRequest{} }
func (m *AuthRequest) String() string { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()    {}
func (*AuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{6}
}
func (m *AuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthRequest.Merge(m, src)
}
func (m *AuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *AuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthRequest proto.InternalMessageInfo

type isAuthRequest_Creds interface {
	isAuthRequest_Creds()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthRequest_UserCreds struct {
	UserCreds *UserCreds `protobuf:"bytes,1,opt,name=userCreds,proto3,oneof" json:"userCreds,omitempty"`
}
type AuthRequest_OauthClientSecretCreds struct {
	OauthClientSecretCreds *OAuthClientSecretCreds `protobuf:"bytes,2,opt,name=oauthClientSecretCreds,proto3,oneof" json:"oauthClientSecretCreds,omitempty"`
}
type AuthRequest_OAuthCodeCreds struct {
	OAuthCodeCreds *OAuthCodeCreds `protobuf:"bytes,3,opt,name=OAuthCodeCreds,proto3,oneof" json:"OAuthCodeCreds,omitempty"`
}

func (*AuthRequest_UserCreds) isAuthRequest_Creds()              {}
func (*AuthRequest_OauthClientSecretCreds) isAuthRequest_Creds() {}
func (*AuthRequest_OAuthCodeCreds) isAuthRequest_Creds()         {}

func (m *AuthRequest) GetCreds() isAuthRequest_Creds {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *AuthRequest) GetUserCreds() *UserCreds {
	if x, ok := m.GetCreds().(*AuthRequest_UserCreds); ok {
		return x.UserCreds
	}
	return nil
}

func (m *AuthRequest) GetOauthClientSecretCreds() *OAuthClientSecretCreds {
	if x, ok := m.GetCreds().(*AuthRequest_OauthClientSecretCreds); ok {
		return x.OauthClientSecretCreds
	}
	return nil
}

func (m *AuthRequest) GetOAuthCodeCreds() *OAuthCodeCreds {
	if x, ok := m.GetCreds().(*AuthRequest_OAuthCodeCreds); ok {
		return x.OAuthCodeCreds
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AuthRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AuthRequest_UserCreds)(nil),
		(*AuthRequest_OauthClientSecretCreds)(nil),
		(*AuthRequest_OAuthCodeCreds)(nil),
	}
}

type AuthResponse struct {
	Success     bool         `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Tokens      *Tokens      `protobuf:"bytes,2,opt,name=tokens,proto3" json:"tokens,omitempty"`
	MFAResponse *MFAResponse `protobuf:"bytes,3,opt,name=MFAResponse,proto3" json:"MFAResponse,omitempty"`
}

func (m *AuthResponse) Reset()         { *m = AuthResponse{} }
func (m *AuthResponse) String() string { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()    {}
func (*AuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{7}
}
func (m *AuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthResponse.Merge(m, src)
}
func (m *AuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *AuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AuthResponse proto.InternalMessageInfo

func (m *AuthResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AuthResponse) GetTokens() *Tokens {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *AuthResponse) GetMFAResponse() *MFAResponse {
	if m != nil {
		return m.MFAResponse
	}
	return nil
}

type MFAResponse struct {
	Type MFAResponse_MFAType `protobuf:"varint,1,opt,name=type,proto3,enum=ataas.passport.MFAResponse_MFAType" json:"type,omitempty"`
	// Types that are valid to be assigned to Challenge:
	//	*MFAResponse_Fido
	Challenge isMFAResponse_Challenge `protobuf_oneof:"challenge"`
}

func (m *MFAResponse) Reset()         { *m = MFAResponse{} }
func (m *MFAResponse) String() string { return proto.CompactTextString(m) }
func (*MFAResponse) ProtoMessage()    {}
func (*MFAResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{8}
}
func (m *MFAResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFAResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFAResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFAResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFAResponse.Merge(m, src)
}
func (m *MFAResponse) XXX_Size() int {
	return m.Size()
}
func (m *MFAResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MFAResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MFAResponse proto.InternalMessageInfo

type isMFAResponse_Challenge interface {
	isMFAResponse_Challenge()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MFAResponse_Fido struct {
	Fido *FIDOChallenge `protobuf:"bytes,2,opt,name=fido,proto3,oneof" json:"fido,omitempty"`
}

func (*MFAResponse_Fido) isMFAResponse_Challenge() {}

func (m *MFAResponse) GetChallenge() isMFAResponse_Challenge {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *MFAResponse) GetType() MFAResponse_MFAType {
	if m != nil {
		return m.Type
	}
	return MFAResponse_TOTP
}

func (m *MFAResponse) GetFido() *FIDOChallenge {
	if x, ok := m.GetChallenge().(*MFAResponse_Fido); ok {
		return x.Fido
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MFAResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MFAResponse_Fido)(nil),
	}
}

type FIDOChallenge struct {
	Challenge     string   `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge,omitempty"`
	Timestamp     int64    `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	AppId         string   `protobuf:"bytes,3,opt,name=appId,proto3" json:"appId,omitempty"`
	TrustedFacets []string `protobuf:"bytes,4,rep,name=trustedFacets,proto3" json:"trustedFacets,omitempty"`
}

func (m *FIDOChallenge) Reset()         { *m = FIDOChallenge{} }
func (m *FIDOChallenge) String() string { return proto.CompactTextString(m) }
func (*FIDOChallenge) ProtoMessage()    {}
func (*FIDOChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{9}
}
func (m *FIDOChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FIDOChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FIDOChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FIDOChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FIDOChallenge.Merge(m, src)
}
func (m *FIDOChallenge) XXX_Size() int {
	return m.Size()
}
func (m *FIDOChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_FIDOChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_FIDOChallenge proto.InternalMessageInfo

func (m *FIDOChallenge) GetChallenge() string {
	if m != nil {
		return m.Challenge
	}
	return ""
}

func (m *FIDOChallenge) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FIDOChallenge) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *FIDOChallenge) GetTrustedFacets() []string {
	if m != nil {
		return m.TrustedFacets
	}
	return nil
}

type RefreshRequest struct {
	RefreshToken string `protobuf:"bytes,1,opt,name=refreshToken,proto3" json:"refreshToken,omitempty"`
}

func (m *RefreshRequest) Reset()         { *m = RefreshRequest{} }
func (m *RefreshRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshRequest) ProtoMessage()    {}
func (*RefreshRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{10}
}
func (m *RefreshRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshRequest.Merge(m, src)
}
func (m *RefreshRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshRequest proto.InternalMessageInfo

func (m *RefreshRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type SocialRequest struct {
	Provider  string  `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	IdpTokens *Tokens `protobuf:"bytes,2,opt,name=idpTokens,proto3" json:"idpTokens,omitempty"`
}

func (m *SocialRequest) Reset()         { *m = SocialRequest{} }
func (m *SocialRequest) String() string { return proto.CompactTextString(m) }
func (*SocialRequest) ProtoMessage()    {}
func (*SocialRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{11}
}
func (m *SocialRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SocialRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SocialRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SocialRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SocialRequest.Merge(m, src)
}
func (m *SocialRequest) XXX_Size() int {
	return m.Size()
}
func (m *SocialRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SocialRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SocialRequest proto.InternalMessageInfo

func (m *SocialRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *SocialRequest) GetIdpTokens() *Tokens {
	if m != nil {
		return m.IdpTokens
	}
	return nil
}

type Revoke struct {
	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Jti    string `protobuf:"bytes,2,opt,name=jti,proto3" json:"jti,omitempty"`
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Revoke) Reset()         { *m = Revoke{} }
func (m *Revoke) String() string { return proto.CompactTextString(m) }
func (*Revoke) ProtoMessage()    {}
func (*Revoke) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{12}
}
func (m *Revoke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Revoke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Revoke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Revoke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Revoke.Merge(m, src)
}
func (m *Revoke) XXX_Size() int {
	return m.Size()
}
func (m *Revoke) XXX_DiscardUnknown() {
	xxx_messageInfo_Revoke.DiscardUnknown(m)
}

var xxx_messageInfo_Revoke proto.InternalMessageInfo

func (m *Revoke) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Revoke) GetJti() string {
	if m != nil {
		return m.Jti
	}
	return ""
}

func (m *Revoke) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type Session struct {
	UserAgent string `protobuf:"bytes,1,opt,name=userAgent,proto3" json:"userAgent,omitempty"`
	Ip        string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Jti       string `protobuf:"bytes,3,opt,name=jti,proto3" json:"jti,omitempty"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{13}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *Session) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Session) GetJti() string {
	if m != nil {
		return m.Jti
	}
	return ""
}

type SessionList struct {
	Sessions []*Session `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
}

func (m *SessionList) Reset()         { *m = SessionList{} }
func (m *SessionList) String() string { return proto.CompactTextString(m) }
func (*SessionList) ProtoMessage()    {}
func (*SessionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{14}
}
func (m *SessionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionList.Merge(m, src)
}
func (m *SessionList) XXX_Size() int {
	return m.Size()
}
func (m *SessionList) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionList.DiscardUnknown(m)
}

var xxx_messageInfo_SessionList proto.InternalMessageInfo

func (m *SessionList) GetSessions() []*Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{15}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ataas.passport.MFAResponse_MFAType", MFAResponse_MFAType_name, MFAResponse_MFAType_value)
	proto.RegisterType((*Tokens)(nil), "ataas.passport.Tokens")
	proto.RegisterType((*VerifyTokenRequest)(nil), "ataas.passport.VerifyTokenRequest")
	proto.RegisterType((*VerifyTokenResponse)(nil), "ataas.passport.VerifyTokenResponse")
	proto.RegisterType((*UserCreds)(nil), "ataas.passport.UserCreds")
	proto.RegisterType((*OAuthClientSecretCreds)(nil), "ataas.passport.OAuthClientSecretCreds")
	proto.RegisterType((*OAuthCodeCreds)(nil), "ataas.passport.OAuthCodeCreds")
	proto.RegisterType((*AuthRequest)(nil), "ataas.passport.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "ataas.passport.AuthResponse")
	proto.RegisterType((*MFAResponse)(nil), "ataas.passport.MFAResponse")
	proto.RegisterType((*FIDOChallenge)(nil), "ataas.passport.FIDOChallenge")
	proto.RegisterType((*RefreshRequest)(nil), "ataas.passport.RefreshRequest")
	proto.RegisterType((*SocialRequest)(nil), "ataas.passport.SocialRequest")
	proto.RegisterType((*Revoke)(nil), "ataas.passport.Revoke")
	proto.RegisterType((*Session)(nil), "ataas.passport.Session")
	proto.RegisterType((*SessionList)(nil), "ataas.passport.SessionList")
	proto.RegisterType((*Empty)(nil), "ataas.passport.Empty")
}

func init() { proto.RegisterFile("passport.proto", fileDescriptor_4affa6d033a78188) }

var fileDescriptor_4affa6d033a78188 = []byte{
	// 1098 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0x25, 0x59, 0x1f, 0xc3, 0x44, 0xd1, 0xbb, 0x49, 0x1c, 0x45, 0x76, 0x04, 0x63, 0x13,
	0x04, 0x46, 0x5e, 0x40, 0x42, 0xe5, 0x00, 0x45, 0x0b, 0xf4, 0x60, 0xbb, 0x36, 0xec, 0x22, 0x86,
	0x0d, 0xca, 0x4d, 0x8b, 0x1c, 0x8a, 0x6e, 0xc8, 0xb1, 0xcc, 0x5a, 0xe2, 0xb2, 0xdc, 0x95, 0x12,
	0x5d, 0xdb, 0x43, 0x81, 0x02, 0x05, 0x0a, 0xf4, 0xd0, 0x9f, 0xd1, 0xfe, 0x87, 0x5e, 0x7a, 0x0c,
	0xd0, 0x4b, 0x8f, 0x85, 0xdd, 0x1f, 0x52, 0xec, 0x07, 0x65, 0x8b, 0x92, 0x93, 0xdc, 0x66, 0x66,
	0x67, 0x9e, 0x99, 0xd9, 0x7d, 0x66, 0x48, 0xa8, 0xc5, 0x4c, 0x88, 0x98, 0x27, 0xb2, 0x1d, 0x27,
	0x5c, 0x72, 0x52, 0x63, 0x92, 0x31, 0xd1, 0x4e, 0xad, 0xcd, 0xd5, 0x3e, 0xe7, 0xfd, 0x01, 0x76,
	0x58, 0x1c, 0x76, 0x58, 0x14, 0x71, 0xc9, 0x64, 0xc8, 0x23, 0x61, 0xbc, 0x9b, 0xd0, 0xe7, 0x7d,
	0x6e, 0x64, 0xfa, 0xa3, 0x03, 0xa5, 0x63, 0x7e, 0x86, 0x91, 0x20, 0x77, 0x60, 0x49, 0x2a, 0xa9,
	0xe1, 0xac, 0x39, 0xeb, 0x55, 0xcf, 0x28, 0x64, 0x0d, 0x5c, 0x2d, 0xec, 0xbc, 0x8e, 0xc3, 0x04,
	0x1b, 0xf9, 0x35, 0x67, 0xbd, 0xe0, 0x5d, 0x35, 0x11, 0x0a, 0x37, 0x12, 0x3c, 0x49, 0x50, 0x9c,
	0x6a, 0xa0, 0x46, 0x41, 0x87, 0xcf, 0xd8, 0xc8, 0x23, 0xb8, 0x69, 0x75, 0x8b, 0x53, 0xd4, 0x38,
	0xb3, 0x46, 0xfa, 0x04, 0xc8, 0x73, 0x4c, 0xc2, 0x93, 0x89, 0x0e, 0xf2, 0xf0, 0xdb, 0x11, 0x0a,
	0xb9, 0xb8, 0x2e, 0xfa, 0x93, 0x03, 0xb7, 0x67, 0x9c, 0x45, 0xcc, 0x23, 0x81, 0xca, 0x7b, 0xcc,
	0x06, 0x61, 0xa0, 0xbd, 0x2b, 0x9e, 0x51, 0x48, 0x03, 0xca, 0x09, 0x8e, 0xf9, 0x19, 0x06, 0xba,
	0x83, 0x8a, 0x97, 0xaa, 0xd9, 0xfe, 0x0a, 0xf3, 0xfd, 0xbd, 0x5f, 0xed, 0x7f, 0x38, 0x50, 0xfd,
	0x5c, 0x60, 0xb2, 0x9d, 0x60, 0x20, 0x48, 0x13, 0x2a, 0x23, 0x81, 0x49, 0xc4, 0x86, 0x68, 0xcb,
	0x9e, 0xea, 0xea, 0x4c, 0x3d, 0xd4, 0x2b, 0x9e, 0x98, 0x62, 0xaa, 0xde, 0x54, 0x27, 0x75, 0x28,
	0x1c, 0xec, 0x6e, 0xda, 0x2b, 0x54, 0xa2, 0xea, 0x27, 0xc0, 0xf1, 0xee, 0x91, 0xce, 0x5a, 0xf5,
	0x8c, 0xa2, 0x6a, 0x0a, 0x23, 0x81, 0xfe, 0x28, 0xc1, 0x67, 0xbc, 0x1f, 0x46, 0x8d, 0x25, 0xdd,
	0xd5, 0xac, 0x91, 0xac, 0x42, 0x35, 0x41, 0x9f, 0xc5, 0xd2, 0x3f, 0x65, 0x8d, 0x92, 0x8e, 0xbf,
	0x34, 0x10, 0x02, 0xc5, 0x08, 0x5f, 0xcb, 0x46, 0x59, 0x87, 0x6a, 0x99, 0xbe, 0x80, 0xe5, 0xc3,
	0xcd, 0x91, 0x3c, 0xdd, 0x1e, 0x84, 0x18, 0xc9, 0x1e, 0xfa, 0x09, 0x4a, 0xd3, 0x51, 0x1d, 0x0a,
	0x67, 0x38, 0xb1, 0xcd, 0x28, 0x91, 0x2c, 0x43, 0x49, 0x68, 0x07, 0xdb, 0x85, 0xd5, 0xb4, 0xdd,
	0xe7, 0x31, 0x8a, 0x46, 0x61, 0xad, 0xa0, 0xed, 0x5a, 0xa3, 0x8f, 0xa0, 0x66, 0xb0, 0x79, 0x80,
	0x06, 0x93, 0x40, 0xd1, 0xe7, 0x41, 0x7a, 0x43, 0x5a, 0xa6, 0xdf, 0xe7, 0xc1, 0x55, 0x5e, 0xe9,
	0xeb, 0x7f, 0x04, 0xd5, 0x51, 0x7a, 0xad, 0xda, 0xd1, 0xed, 0xde, 0x6f, 0xcf, 0xd2, 0xbd, 0x3d,
	0xbd, 0xf7, 0xbd, 0x9c, 0x77, 0xe9, 0x4d, 0xbe, 0x86, 0x65, 0xce, 0x16, 0x35, 0xa3, 0x0b, 0x76,
	0xbb, 0x8f, 0xb3, 0x38, 0x8b, 0x5b, 0xdf, 0xcb, 0x79, 0xd7, 0xe0, 0x90, 0xbd, 0x6c, 0x4b, 0xfa,
	0xe5, 0xdc, 0x6e, 0x6b, 0x31, 0x72, 0xea, 0xb5, 0x97, 0xf3, 0x32, 0x71, 0x5b, 0x65, 0x58, 0xf2,
	0x95, 0xf0, 0x59, 0xb1, 0x52, 0xac, 0x6f, 0xd0, 0x5f, 0x1d, 0xb8, 0x61, 0x6e, 0xc1, 0xd2, 0xba,
	0x01, 0x65, 0x31, 0xf2, 0x7d, 0x14, 0xc2, 0x12, 0x3b, 0x55, 0x49, 0x1b, 0x4a, 0x9a, 0xad, 0x69,
	0x57, 0xcb, 0xd9, 0xdc, 0x66, 0xbc, 0x3d, 0xeb, 0x45, 0x3e, 0x01, 0xf7, 0x60, 0x77, 0x33, 0x05,
	0xb6, 0x05, 0xaf, 0x64, 0x83, 0xae, 0xb8, 0x78, 0x57, 0xfd, 0xe9, 0xef, 0xce, 0x4c, 0x3c, 0xf9,
	0x10, 0x8a, 0x72, 0x12, 0x9b, 0x37, 0xac, 0x75, 0x1f, 0xbe, 0x05, 0x47, 0xc9, 0xc7, 0x93, 0x18,
	0x3d, 0x1d, 0x40, 0x36, 0xa0, 0x78, 0x12, 0x06, 0xdc, 0x56, 0xfd, 0x20, 0x1b, 0xb8, 0xbb, 0xff,
	0xe9, 0xe1, 0xf6, 0x29, 0x1b, 0x0c, 0x30, 0xea, 0xe3, 0x5e, 0xce, 0xd3, 0xce, 0xf4, 0x31, 0x94,
	0x2d, 0x0a, 0xa9, 0x40, 0xf1, 0xf8, 0xf0, 0xf8, 0xa8, 0x9e, 0x53, 0x92, 0xf2, 0xae, 0x3b, 0xa4,
	0x0c, 0x85, 0xde, 0x41, 0xaf, 0x9e, 0xdf, 0x72, 0xa1, 0xea, 0xa7, 0xc1, 0xf4, 0x07, 0x07, 0x6e,
	0xce, 0xc0, 0xa9, 0xc1, 0x98, 0x1e, 0x5b, 0xf6, 0x5d, 0x1a, 0xd4, 0xa9, 0x0c, 0x87, 0x28, 0x24,
	0x1b, 0xc6, 0x76, 0xe1, 0x5d, 0x1a, 0xd4, 0x40, 0xb2, 0x38, 0xde, 0x0f, 0xec, 0x90, 0x1a, 0x45,
	0x0d, 0xa4, 0x4c, 0x46, 0x42, 0x62, 0xb0, 0xcb, 0x7c, 0x94, 0xa2, 0x51, 0xd4, 0xdc, 0x9f, 0x35,
	0xd2, 0xa7, 0x50, 0xf3, 0xcc, 0xd6, 0x48, 0xe9, 0x9d, 0x5d, 0x9e, 0xce, 0xfc, 0xf2, 0xa4, 0x0c,
	0x6e, 0xf6, 0xb8, 0x1f, 0xb2, 0x41, 0x1a, 0xa4, 0x36, 0x48, 0xc2, 0xc7, 0x61, 0x80, 0x49, 0xba,
	0x5d, 0x52, 0x9d, 0x3c, 0x85, 0x6a, 0x18, 0xc4, 0xc7, 0xef, 0xc3, 0x88, 0x4b, 0x47, 0xba, 0x05,
	0x25, 0x4f, 0x2f, 0x44, 0x52, 0x83, 0xbc, 0x5d, 0x9e, 0x55, 0x2f, 0x1f, 0xea, 0x8d, 0xf4, 0x8d,
	0x0c, 0xed, 0x88, 0x2b, 0x51, 0xcd, 0x77, 0x82, 0x4c, 0xf0, 0x74, 0xd3, 0x5b, 0x8d, 0xee, 0x43,
	0xb9, 0x87, 0x42, 0x84, 0x5c, 0x2f, 0x1e, 0x35, 0x86, 0x9b, 0x7d, 0x8c, 0x64, 0x7a, 0xbf, 0x53,
	0x83, 0x4e, 0x11, 0x5b, 0xc4, 0x7c, 0x18, 0xa7, 0x29, 0x0a, 0xd3, 0x14, 0x74, 0x0b, 0x5c, 0x0b,
	0xf5, 0x2c, 0x14, 0x92, 0x6c, 0x40, 0x45, 0x18, 0x55, 0xb1, 0xbf, 0xb0, 0xee, 0x76, 0xef, 0x65,
	0x5b, 0xb2, 0xee, 0xde, 0xd4, 0x91, 0x96, 0x61, 0x69, 0x67, 0x18, 0xcb, 0x49, 0xf7, 0xb7, 0x25,
	0xa8, 0x1d, 0x59, 0xbf, 0x1e, 0x8e, 0x43, 0x1f, 0xc9, 0x73, 0x70, 0xaf, 0x7c, 0x3b, 0x08, 0xcd,
	0xa2, 0xcd, 0x7f, 0x85, 0x9a, 0x0f, 0xdf, 0xea, 0x63, 0x87, 0x21, 0x30, 0x53, 0x8b, 0x91, 0x0c,
	0x7d, 0x26, 0x91, 0xcc, 0x8d, 0xd5, 0x95, 0xcd, 0xd6, 0x5c, 0x5d, 0x7c, 0x68, 0xe7, 0xec, 0xfe,
	0x77, 0x7f, 0xfd, 0xfb, 0x4b, 0xfe, 0x36, 0xad, 0x75, 0xc6, 0x1f, 0x74, 0xd4, 0xf6, 0xe9, 0x0c,
	0xd4, 0x4e, 0xff, 0xd8, 0x79, 0x42, 0x02, 0x28, 0x5b, 0x16, 0x91, 0xb9, 0x45, 0x33, 0x4b, 0xaf,
	0x77, 0xe4, 0x58, 0xd1, 0x39, 0xee, 0xd2, 0xfa, 0x34, 0x87, 0xe5, 0x9d, 0xca, 0x72, 0x02, 0xae,
	0x61, 0x9d, 0xf9, 0x96, 0xcc, 0x0d, 0xe8, 0x0c, 0x25, 0xdf, 0x91, 0xa8, 0xa9, 0x13, 0xdd, 0xa1,
	0xb7, 0xa6, 0x89, 0x84, 0x8e, 0x56, 0x79, 0xbe, 0x04, 0xd7, 0x50, 0xcf, 0xbc, 0xc5, 0xf2, 0x7c,
	0x47, 0xea, 0xb0, 0x79, 0x37, 0x6b, 0xd7, 0x8f, 0xbb, 0x00, 0xd9, 0x7c, 0xd8, 0x15, 0xf2, 0x57,
	0x70, 0xcb, 0x04, 0x6f, 0x0e, 0x06, 0xf6, 0x1f, 0x67, 0x31, 0xca, 0x75, 0xe0, 0x0f, 0x34, 0xf8,
	0x3d, 0x4a, 0x32, 0xe0, 0x6c, 0xa0, 0x2b, 0xff, 0x02, 0x2a, 0x96, 0x76, 0xd7, 0x02, 0xaf, 0x5c,
	0xc3, 0x53, 0x45, 0x6b, 0x7a, 0x4f, 0xc3, 0xff, 0x8f, 0xe8, 0xda, 0x87, 0x93, 0x4e, 0x4a, 0xdd,
	0xad, 0x9d, 0x3f, 0xcf, 0x5b, 0xce, 0x9b, 0xf3, 0x96, 0xf3, 0xcf, 0x79, 0xcb, 0xf9, 0xf9, 0xa2,
	0x95, 0x7b, 0x73, 0xd1, 0xca, 0xfd, 0x7d, 0xd1, 0xca, 0xbd, 0xf8, 0x7f, 0x3c, 0x6c, 0x4b, 0xff,
	0xe4, 0x55, 0xdb, 0xe7, 0xc3, 0x36, 0x1b, 0x75, 0x04, 0x1f, 0x25, 0x3e, 0x76, 0x74, 0x12, 0xfd,
	0xb7, 0x17, 0xbf, 0xec, 0xa4, 0xb9, 0x5e, 0x96, 0xf4, 0x2f, 0xde, 0xc6, 0x7f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x60, 0x2d, 0x92, 0x65, 0x2e, 0x0a, 0x00, 0x00,
}

func (m *Tokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tokens) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tokens) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefreshExpire != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.RefreshExpire))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TokenExpire != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.TokenExpire))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerifyTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefreshExpire != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.RefreshExpire))
		i--
		dAtA[i] = 0x20
	}
	if m.TokenExpire != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.TokenExpire))
		i--
		dAtA[i] = 0x18
	}
	if m.Revoked {
		i--
		if m.Revoked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Valid {
		i--
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Next {
		i--
		if m.Next {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Recaptcha) > 0 {
		i -= len(m.Recaptcha)
		copy(dAtA[i:], m.Recaptcha)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Recaptcha)))
		i--
		dAtA[i] = 0x32
	}
	if m.InsecureLogin {
		i--
		if m.InsecureLogin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.DevFP) > 0 {
		i -= len(m.DevFP)
		copy(dAtA[i:], m.DevFP)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.DevFP)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MFA) > 0 {
		i -= len(m.MFA)
		copy(dAtA[i:], m.MFA)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.MFA)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OAuthClientSecretCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthClientSecretCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OAuthClientSecretCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Scopes[iNdEx])
			copy(dAtA[i:], m.Scopes[iNdEx])
			i = encodeVarintPassport(dAtA, i, uint64(len(m.Scopes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OAuthCodeCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthCodeCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OAuthCodeCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size := m.Creds.Size()
			i -= size
			if _, err := m.Creds.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthRequest_UserCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest_UserCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UserCreds != nil {
		{
			size, err := m.UserCreds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AuthRequest_OauthClientSecretCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest_OauthClientSecretCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OauthClientSecretCreds != nil {
		{
			size, err := m.OauthClientSecretCreds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AuthRequest_OAuthCodeCreds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthRequest_OAuthCodeCreds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OAuthCodeCreds != nil {
		{
			size, err := m.OAuthCodeCreds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MFAResponse != nil {
		{
			size, err := m.MFAResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Tokens != nil {
		{
			size, err := m.Tokens.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MFAResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Challenge != nil {
		{
			size := m.Challenge.Size()
			i -= size
			if _, err := m.Challenge.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MFAResponse_Fido) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAResponse_Fido) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Fido != nil {
		{
			size, err := m.Fido.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FIDOChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FIDOChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FIDOChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedFacets) > 0 {
		for iNdEx := len(m.TrustedFacets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TrustedFacets[iNdEx])
			copy(dAtA[i:], m.TrustedFacets[iNdEx])
			i = encodeVarintPassport(dAtA, i, uint64(len(m.TrustedFacets[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AppId) > 0 {
		i -= len(m.AppId)
		copy(dAtA[i:], m.AppId)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.AppId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RefreshRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SocialRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocialRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SocialRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IdpTokens != nil {
		{
			size, err := m.IdpTokens.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Revoke) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Revoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Revoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Jti) > 0 {
		i -= len(m.Jti)
		copy(dAtA[i:], m.Jti)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Jti)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Jti) > 0 {
		i -= len(m.Jti)
		copy(dAtA[i:], m.Jti)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Jti)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SessionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for iNdEx := len(m.Sessions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sessions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPassport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPassport(dAtA []byte, offset int, v uint64) int {
	offset -= sovPassport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Tokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.TokenExpire != 0 {
		n += 1 + sovPassport(uint64(m.TokenExpire))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.RefreshExpire != 0 {
		n += 1 + sovPassport(uint64(m.RefreshExpire))
	}
	return n
}

func (m *VerifyTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *VerifyTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Valid {
		n += 2
	}
	if m.Revoked {
		n += 2
	}
	if m.TokenExpire != 0 {
		n += 1 + sovPassport(uint64(m.TokenExpire))
	}
	if m.RefreshExpire != 0 {
		n += 1 + sovPassport(uint64(m.RefreshExpire))
	}
	return n
}

func (m *UserCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.MFA)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.DevFP)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.InsecureLogin {
		n += 2
	}
	l = len(m.Recaptcha)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.Next {
		n += 2
	}
	return n
}

func (m *OAuthClientSecretCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			l = len(s)
			n += 1 + l + sovPassport(uint64(l))
		}
	}
	return n
}

func (m *OAuthCodeCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *AuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		n += m.Creds.Size()
	}
	return n
}

func (m *AuthRequest_UserCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserCreds != nil {
		l = m.UserCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthRequest_OauthClientSecretCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OauthClientSecretCreds != nil {
		l = m.OauthClientSecretCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthRequest_OAuthCodeCreds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OAuthCodeCreds != nil {
		l = m.OAuthCodeCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Tokens != nil {
		l = m.Tokens.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.MFAResponse != nil {
		l = m.MFAResponse.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *MFAResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPassport(uint64(m.Type))
	}
	if m.Challenge != nil {
		n += m.Challenge.Size()
	}
	return n
}

func (m *MFAResponse_Fido) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fido != nil {
		l = m.Fido.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *FIDOChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovPassport(uint64(m.Timestamp))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if len(m.TrustedFacets) > 0 {
		for _, s := range m.TrustedFacets {
			l = len(s)
			n += 1 + l + sovPassport(uint64(l))
		}
	}
	return n
}

func (m *RefreshRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *SocialRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.IdpTokens != nil {
		l = m.IdpTokens.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *Revoke) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Jti)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Jti)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *SessionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovPassport(uint64(l))
		}
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPassport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPassport(x uint64) (n int) {
	return sovPassport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenExpire", wireType)
			}
			m.TokenExpire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenExpire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshExpire", wireType)
			}
			m.RefreshExpire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshExpire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoked = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenExpire", wireType)
			}
			m.TokenExpire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenExpire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshExpire", wireType)
			}
			m.RefreshExpire = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshExpire |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MFA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevFP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevFP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsecureLogin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InsecureLogin = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recaptcha", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recaptcha = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Next = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthClientSecretCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthClientSecretCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthClientSecretCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthCodeCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthCodeCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthCodeCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_UserCreds{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OauthClientSecretCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OAuthClientSecretCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_OauthClientSecretCreds{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OAuthCodeCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OAuthCodeCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_OAuthCodeCreds{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = &Tokens{}
			}
			if err := m.Tokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFAResponse == nil {
				m.MFAResponse = &MFAResponse{}
			}
			if err := m.MFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFAResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MFAResponse_MFAType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fido", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FIDOChallenge{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Challenge = &MFAResponse_Fido{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FIDOChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FIDOChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FIDOChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedFacets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedFacets = append(m.TrustedFacets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocialRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocialRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocialRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdpTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdpTokens == nil {
				m.IdpTokens = &Tokens{}
			}
			if err := m.IdpTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Revoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Revoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Revoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPassport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPassport
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPassport
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPassport
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPassport        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPassport          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPassport = fmt.Errorf("proto: unexpected end of group")
)
