// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ticks.proto

package ticks

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TradeDirection int32

const (
	TradeDirection_BUY  TradeDirection = 0
	TradeDirection_SELL TradeDirection = 1
)

var TradeDirection_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}

var TradeDirection_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x TradeDirection) String() string {
	return proto.EnumName(TradeDirection_name, int32(x))
}

func (TradeDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{0}
}

type Tick struct {
	Market              string  `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument          string  `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	BestBid             float32 `protobuf:"fixed32,3,opt,name=bestBid,proto3" json:"bestBid,omitempty"`
	BestAsk             float32 `protobuf:"fixed32,4,opt,name=bestAsk,proto3" json:"bestAsk,omitempty"`
	Last                float32 `protobuf:"fixed32,5,opt,name=last,proto3" json:"last,omitempty"`
	Timestamp           float32 `protobuf:"fixed32,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Volume24H           float32 `protobuf:"fixed32,7,opt,name=volume24h,proto3" json:"volume24h,omitempty"`
	Highest24H          float32 `protobuf:"fixed32,8,opt,name=highest24h,proto3" json:"highest24h,omitempty"`
	Lowest24H           float32 `protobuf:"fixed32,9,opt,name=lowest24h,proto3" json:"lowest24h,omitempty"`
	ClosePriceChange24H float32 `protobuf:"fixed32,10,opt,name=closePriceChange24h,proto3" json:"closePriceChange24h,omitempty"`
	Open                float32 `protobuf:"fixed32,11,opt,name=open,proto3" json:"open,omitempty"`
}

func (m *Tick) Reset()         { *m = Tick{} }
func (m *Tick) String() string { return proto.CompactTextString(m) }
func (*Tick) ProtoMessage()    {}
func (*Tick) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{0}
}
func (m *Tick) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tick.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tick.Merge(m, src)
}
func (m *Tick) XXX_Size() int {
	return m.Size()
}
func (m *Tick) XXX_DiscardUnknown() {
	xxx_messageInfo_Tick.DiscardUnknown(m)
}

var xxx_messageInfo_Tick proto.InternalMessageInfo

func (m *Tick) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *Tick) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *Tick) GetBestBid() float32 {
	if m != nil {
		return m.BestBid
	}
	return 0
}

func (m *Tick) GetBestAsk() float32 {
	if m != nil {
		return m.BestAsk
	}
	return 0
}

func (m *Tick) GetLast() float32 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *Tick) GetTimestamp() float32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Tick) GetVolume24H() float32 {
	if m != nil {
		return m.Volume24H
	}
	return 0
}

func (m *Tick) GetHighest24H() float32 {
	if m != nil {
		return m.Highest24H
	}
	return 0
}

func (m *Tick) GetLowest24H() float32 {
	if m != nil {
		return m.Lowest24H
	}
	return 0
}

func (m *Tick) GetClosePriceChange24H() float32 {
	if m != nil {
		return m.ClosePriceChange24H
	}
	return 0
}

func (m *Tick) GetOpen() float32 {
	if m != nil {
		return m.Open
	}
	return 0
}

type OHLCV struct {
	Market     string  `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument string  `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	Open       float32 `protobuf:"fixed32,3,opt,name=open,proto3" json:"open,omitempty"`
	High       float32 `protobuf:"fixed32,4,opt,name=high,proto3" json:"high,omitempty"`
	Low        float32 `protobuf:"fixed32,5,opt,name=low,proto3" json:"low,omitempty"`
	Close      float32 `protobuf:"fixed32,6,opt,name=close,proto3" json:"close,omitempty"`
	Volume     int32   `protobuf:"varint,7,opt,name=volume,proto3" json:"volume,omitempty"`
	Timestamp  int64   `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *OHLCV) Reset()         { *m = OHLCV{} }
func (m *OHLCV) String() string { return proto.CompactTextString(m) }
func (*OHLCV) ProtoMessage()    {}
func (*OHLCV) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{1}
}
func (m *OHLCV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OHLCV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OHLCV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OHLCV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OHLCV.Merge(m, src)
}
func (m *OHLCV) XXX_Size() int {
	return m.Size()
}
func (m *OHLCV) XXX_DiscardUnknown() {
	xxx_messageInfo_OHLCV.DiscardUnknown(m)
}

var xxx_messageInfo_OHLCV proto.InternalMessageInfo

func (m *OHLCV) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *OHLCV) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *OHLCV) GetOpen() float32 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *OHLCV) GetHigh() float32 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *OHLCV) GetLow() float32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *OHLCV) GetClose() float32 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *OHLCV) GetVolume() int32 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *OHLCV) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type Trade struct {
	Market     string         `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty" msgpack:"m"`
	Instrument string         `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty" msgpack:"s"`
	TradeID    string         `protobuf:"bytes,3,opt,name=tradeID,proto3" json:"tradeID,omitempty" msgpack:"i"`
	Direction  TradeDirection `protobuf:"varint,4,opt,name=direction,proto3,enum=trader.ticks.TradeDirection" json:"direction,omitempty" msgpack:"d"`
	Amount     float32        `protobuf:"fixed32,5,opt,name=amount,proto3" json:"amount,omitempty" msgpack:"p"`
	Units      float32        `protobuf:"fixed32,6,opt,name=units,proto3" json:"units,omitempty" msgpack:"q"`
	Timestamp  int64          `protobuf:"varint,7,opt,name=timestamp,proto3" json:"timestamp,omitempty" msgpack:"t"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{2}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *Trade) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *Trade) GetTradeID() string {
	if m != nil {
		return m.TradeID
	}
	return ""
}

func (m *Trade) GetDirection() TradeDirection {
	if m != nil {
		return m.Direction
	}
	return TradeDirection_BUY
}

func (m *Trade) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Trade) GetUnits() float32 {
	if m != nil {
		return m.Units
	}
	return 0
}

func (m *Trade) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type GetRequest struct {
	Market     string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument string `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	Depth      int32  `protobuf:"varint,4,opt,name=depth,proto3" json:"depth,omitempty"`
}

func (m *GetRequest) Reset()         { *m = GetRequest{} }
func (m *GetRequest) String() string { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()    {}
func (*GetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{3}
}
func (m *GetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRequest.Merge(m, src)
}
func (m *GetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRequest proto.InternalMessageInfo

func (m *GetRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *GetRequest) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *GetRequest) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

type TicksResponse struct {
	Ticks []*Tick `protobuf:"bytes,1,rep,name=ticks,proto3" json:"ticks,omitempty"`
}

func (m *TicksResponse) Reset()         { *m = TicksResponse{} }
func (m *TicksResponse) String() string { return proto.CompactTextString(m) }
func (*TicksResponse) ProtoMessage()    {}
func (*TicksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{4}
}
func (m *TicksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TicksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TicksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TicksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TicksResponse.Merge(m, src)
}
func (m *TicksResponse) XXX_Size() int {
	return m.Size()
}
func (m *TicksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TicksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TicksResponse proto.InternalMessageInfo

func (m *TicksResponse) GetTicks() []*Tick {
	if m != nil {
		return m.Ticks
	}
	return nil
}

type TradesResponse struct {
	Data []*Trade `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *TradesResponse) Reset()         { *m = TradesResponse{} }
func (m *TradesResponse) String() string { return proto.CompactTextString(m) }
func (*TradesResponse) ProtoMessage()    {}
func (*TradesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{5}
}
func (m *TradesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradesResponse.Merge(m, src)
}
func (m *TradesResponse) XXX_Size() int {
	return m.Size()
}
func (m *TradesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TradesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TradesResponse proto.InternalMessageInfo

func (m *TradesResponse) GetData() []*Trade {
	if m != nil {
		return m.Data
	}
	return nil
}

type CandlesRequest struct {
	Market     string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument string `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	Interval   string `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
	Depth      int32  `protobuf:"varint,4,opt,name=depth,proto3" json:"depth,omitempty"`
}

func (m *CandlesRequest) Reset()         { *m = CandlesRequest{} }
func (m *CandlesRequest) String() string { return proto.CompactTextString(m) }
func (*CandlesRequest) ProtoMessage()    {}
func (*CandlesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{6}
}
func (m *CandlesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlesRequest.Merge(m, src)
}
func (m *CandlesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CandlesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CandlesRequest proto.InternalMessageInfo

func (m *CandlesRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *CandlesRequest) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *CandlesRequest) GetInterval() string {
	if m != nil {
		return m.Interval
	}
	return ""
}

func (m *CandlesRequest) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

type CandlesResponse struct {
	Data []*OHLCV `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *CandlesResponse) Reset()         { *m = CandlesResponse{} }
func (m *CandlesResponse) String() string { return proto.CompactTextString(m) }
func (*CandlesResponse) ProtoMessage()    {}
func (*CandlesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{7}
}
func (m *CandlesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandlesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandlesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandlesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandlesResponse.Merge(m, src)
}
func (m *CandlesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CandlesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CandlesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CandlesResponse proto.InternalMessageInfo

func (m *CandlesResponse) GetData() []*OHLCV {
	if m != nil {
		return m.Data
	}
	return nil
}

type RangeRequest struct {
	Market     string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument string `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	Since      string `protobuf:"bytes,3,opt,name=since,proto3" json:"since,omitempty"`
}

func (m *RangeRequest) Reset()         { *m = RangeRequest{} }
func (m *RangeRequest) String() string { return proto.CompactTextString(m) }
func (*RangeRequest) ProtoMessage()    {}
func (*RangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{8}
}
func (m *RangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeRequest.Merge(m, src)
}
func (m *RangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *RangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RangeRequest proto.InternalMessageInfo

func (m *RangeRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *RangeRequest) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *RangeRequest) GetSince() string {
	if m != nil {
		return m.Since
	}
	return ""
}

type CompareRequest struct {
	Market     string `protobuf:"bytes,1,opt,name=market,proto3" json:"market,omitempty"`
	Instrument string `protobuf:"bytes,2,opt,name=instrument,proto3" json:"instrument,omitempty"`
	Interval   string `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *CompareRequest) Reset()         { *m = CompareRequest{} }
func (m *CompareRequest) String() string { return proto.CompactTextString(m) }
func (*CompareRequest) ProtoMessage()    {}
func (*CompareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{9}
}
func (m *CompareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompareRequest.Merge(m, src)
}
func (m *CompareRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompareRequest proto.InternalMessageInfo

func (m *CompareRequest) GetMarket() string {
	if m != nil {
		return m.Market
	}
	return ""
}

func (m *CompareRequest) GetInstrument() string {
	if m != nil {
		return m.Instrument
	}
	return ""
}

func (m *CompareRequest) GetInterval() string {
	if m != nil {
		return m.Interval
	}
	return ""
}

type CompareResponse struct {
	Difference float32 `protobuf:"fixed32,1,opt,name=difference,proto3" json:"difference,omitempty"`
}

func (m *CompareResponse) Reset()         { *m = CompareResponse{} }
func (m *CompareResponse) String() string { return proto.CompactTextString(m) }
func (*CompareResponse) ProtoMessage()    {}
func (*CompareResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1d46c2f7535a5e32, []int{10}
}
func (m *CompareResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompareResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompareResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompareResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompareResponse.Merge(m, src)
}
func (m *CompareResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompareResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompareResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompareResponse proto.InternalMessageInfo

func (m *CompareResponse) GetDifference() float32 {
	if m != nil {
		return m.Difference
	}
	return 0
}

func init() {
	proto.RegisterEnum("trader.ticks.TradeDirection", TradeDirection_name, TradeDirection_value)
	proto.RegisterType((*Tick)(nil), "trader.ticks.Tick")
	proto.RegisterType((*OHLCV)(nil), "trader.ticks.OHLCV")
	proto.RegisterType((*Trade)(nil), "trader.ticks.Trade")
	proto.RegisterType((*GetRequest)(nil), "trader.ticks.GetRequest")
	proto.RegisterType((*TicksResponse)(nil), "trader.ticks.TicksResponse")
	proto.RegisterType((*TradesResponse)(nil), "trader.ticks.TradesResponse")
	proto.RegisterType((*CandlesRequest)(nil), "trader.ticks.CandlesRequest")
	proto.RegisterType((*CandlesResponse)(nil), "trader.ticks.CandlesResponse")
	proto.RegisterType((*RangeRequest)(nil), "trader.ticks.RangeRequest")
	proto.RegisterType((*CompareRequest)(nil), "trader.ticks.CompareRequest")
	proto.RegisterType((*CompareResponse)(nil), "trader.ticks.CompareResponse")
}

func init() { proto.RegisterFile("ticks.proto", fileDescriptor_1d46c2f7535a5e32) }

var fileDescriptor_1d46c2f7535a5e32 = []byte{
	// 858 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0xdc, 0x44,
	0x14, 0x8e, 0x77, 0xd7, 0xd9, 0xe4, 0x6c, 0xd9, 0x84, 0x49, 0x40, 0xd6, 0x12, 0x4c, 0x34, 0x08,
	0x35, 0x45, 0x62, 0xdd, 0x06, 0x6e, 0xda, 0xbb, 0x66, 0x0b, 0x14, 0x11, 0x09, 0xe4, 0x14, 0x24,
	0xaa, 0xde, 0x4c, 0xec, 0xc9, 0xee, 0xc8, 0x3f, 0xe3, 0x7a, 0x66, 0x13, 0x01, 0xe2, 0x86, 0x27,
	0x40, 0xe2, 0x99, 0x40, 0x5c, 0x56, 0xe2, 0xa6, 0x57, 0x08, 0x25, 0xbc, 0x00, 0x3c, 0x01, 0x9a,
	0x9f, 0xf5, 0xda, 0x4e, 0x5a, 0x50, 0xa1, 0x77, 0x33, 0xe7, 0x3b, 0x33, 0xdf, 0x39, 0xdf, 0xf9,
	0xc6, 0x32, 0x0c, 0x24, 0x8b, 0x12, 0x31, 0x2e, 0x4a, 0x2e, 0x39, 0xba, 0x26, 0x4b, 0x12, 0xd3,
	0x72, 0xac, 0x63, 0xa3, 0x9d, 0x29, 0xe7, 0xd3, 0x94, 0x06, 0xa4, 0x60, 0x01, 0xc9, 0x73, 0x2e,
	0x89, 0x64, 0x3c, 0xb7, 0xb9, 0x23, 0x98, 0xf2, 0x29, 0x37, 0x6b, 0xfc, 0x73, 0x07, 0x7a, 0x0f,
	0x58, 0x94, 0xa0, 0xd7, 0x61, 0x35, 0x23, 0x65, 0x42, 0xa5, 0xe7, 0xec, 0x3a, 0x7b, 0xeb, 0xa1,
	0xdd, 0x21, 0x1f, 0x80, 0xe5, 0x42, 0x96, 0xf3, 0x8c, 0xe6, 0xd2, 0xeb, 0x68, 0xac, 0x16, 0x41,
	0x1e, 0xf4, 0x8f, 0xa9, 0x90, 0x07, 0x2c, 0xf6, 0xba, 0xbb, 0xce, 0x5e, 0x27, 0x5c, 0x6c, 0x17,
	0xc8, 0x5d, 0x91, 0x78, 0xbd, 0x25, 0x72, 0x57, 0x24, 0x08, 0x41, 0x2f, 0x25, 0x42, 0x7a, 0xae,
	0x0e, 0xeb, 0x35, 0xda, 0x81, 0x75, 0xc9, 0x32, 0x2a, 0x24, 0xc9, 0x0a, 0x6f, 0x55, 0x03, 0xcb,
	0x80, 0x42, 0x4f, 0x79, 0x3a, 0xcf, 0xe8, 0xfe, 0x07, 0x33, 0xaf, 0x6f, 0xd0, 0x2a, 0xa0, 0x6a,
	0x9c, 0xb1, 0xe9, 0x8c, 0x0a, 0xa9, 0xe0, 0x35, 0x0d, 0xd7, 0x22, 0xea, 0x74, 0xca, 0xcf, 0x2c,
	0xbc, 0x6e, 0x4e, 0x57, 0x01, 0x74, 0x13, 0xb6, 0xa2, 0x94, 0x0b, 0xfa, 0x79, 0xc9, 0x22, 0x3a,
	0x99, 0x91, 0x7c, 0xaa, 0x59, 0x40, 0xe7, 0x5d, 0x05, 0xa9, 0xfa, 0x79, 0x41, 0x73, 0x6f, 0x60,
	0xea, 0x57, 0x6b, 0xfc, 0x93, 0x03, 0xee, 0x67, 0xf7, 0x0f, 0x27, 0x5f, 0xbe, 0xb0, 0x92, 0x8b,
	0x5b, 0xbb, 0xcb, 0x5b, 0x55, 0x4c, 0xf5, 0x61, 0x05, 0xd4, 0x6b, 0xb4, 0x09, 0xdd, 0x94, 0x9f,
	0x59, 0xf1, 0xd4, 0x12, 0x6d, 0x83, 0xab, 0xcb, 0xb4, 0xba, 0x99, 0x8d, 0xaa, 0xc3, 0x48, 0xa4,
	0x05, 0x73, 0x43, 0xbb, 0x6b, 0x2a, 0xad, 0xc4, 0xea, 0xd6, 0x94, 0xc6, 0x4f, 0x3b, 0xe0, 0x3e,
	0x50, 0x5e, 0x42, 0xd7, 0x9b, 0x7d, 0x1c, 0x6c, 0xfc, 0xf5, 0xdb, 0x5b, 0x83, 0x4c, 0x4c, 0x0b,
	0x12, 0x25, 0x77, 0x70, 0x86, 0xab, 0xc6, 0x82, 0xcb, 0x8d, 0xb5, 0x92, 0x05, 0x6e, 0x74, 0x7a,
	0x03, 0xfa, 0xda, 0xae, 0x9f, 0xdc, 0xd3, 0xcd, 0xb6, 0xb3, 0x19, 0x0e, 0x17, 0x38, 0xfa, 0x14,
	0xd6, 0x63, 0x56, 0xd2, 0x48, 0xf9, 0x57, 0xab, 0x30, 0xdc, 0xdf, 0x19, 0xd7, 0xbd, 0x3e, 0xd6,
	0xc5, 0xde, 0x5b, 0xe4, 0xb4, 0xae, 0x8a, 0x71, 0xb8, 0x3c, 0xaf, 0x3a, 0x22, 0x19, 0x9f, 0xe7,
	0xd6, 0x79, 0xad, 0xdc, 0x02, 0x87, 0x16, 0x46, 0xef, 0x80, 0x3b, 0xcf, 0x99, 0x14, 0x46, 0xd0,
	0x56, 0xde, 0x63, 0x1c, 0x1a, 0x14, 0xbd, 0x57, 0x57, 0x52, 0x89, 0xdc, 0x6d, 0xa5, 0x4a, 0x5c,
	0x97, 0xf6, 0x21, 0xc0, 0xc7, 0x54, 0x86, 0xf4, 0xf1, 0x9c, 0x0a, 0xf9, 0xc2, 0x36, 0xd9, 0x06,
	0x37, 0xa6, 0x85, 0x34, 0x9e, 0x70, 0x43, 0xb3, 0xc1, 0xb7, 0xe1, 0x15, 0xf5, 0x8c, 0x45, 0x48,
	0x45, 0xc1, 0x73, 0x41, 0xd1, 0x1e, 0xb8, 0x5a, 0x1f, 0xcf, 0xd9, 0xed, 0xee, 0x0d, 0xf6, 0x51,
	0x4b, 0x34, 0x16, 0x25, 0xa1, 0x49, 0xc0, 0xb7, 0x61, 0xa8, 0x35, 0x5c, 0x9e, 0xbd, 0x0e, 0xbd,
	0x98, 0x48, 0x62, 0x8f, 0x6e, 0x5d, 0xa1, 0x77, 0xa8, 0x13, 0xf0, 0x37, 0x30, 0x9c, 0x90, 0x3c,
	0x4e, 0xd5, 0xd9, 0xff, 0xd6, 0xd5, 0x08, 0xd6, 0x58, 0x2e, 0x69, 0x79, 0x4a, 0x52, 0xe3, 0x89,
	0xb0, 0xda, 0x3f, 0xa3, 0xe3, 0x3b, 0xb0, 0x51, 0x71, 0xff, 0x9b, 0xba, 0xf5, 0xe3, 0xb4, 0x75,
	0x3f, 0x82, 0x6b, 0xa1, 0x7a, 0xcc, 0xff, 0xc3, 0x2c, 0x04, 0xcb, 0x23, 0x6a, 0x4b, 0x36, 0x1b,
	0x1c, 0xc3, 0x70, 0xc2, 0xb3, 0x82, 0x94, 0xf4, 0x25, 0xaa, 0x82, 0x6f, 0xc1, 0x46, 0xc5, 0x62,
	0xfb, 0xf7, 0x01, 0x62, 0x76, 0x72, 0x42, 0x4b, 0xaa, 0x6a, 0x72, 0xcc, 0x77, 0x70, 0x19, 0x79,
	0xf7, 0x6d, 0x3b, 0xe9, 0xea, 0xb5, 0xa0, 0x3e, 0x74, 0x0f, 0xbe, 0xf8, 0x6a, 0x73, 0x05, 0xad,
	0x41, 0xef, 0xe8, 0xc3, 0xc3, 0xc3, 0x4d, 0x67, 0xff, 0xcf, 0x2e, 0x0c, 0xef, 0x33, 0x21, 0x79,
	0xf9, 0xf5, 0x11, 0x2d, 0x4f, 0x59, 0x44, 0xd1, 0x23, 0x58, 0x35, 0x0e, 0x41, 0x5e, 0x53, 0xd3,
	0xa5, 0x9d, 0x47, 0x57, 0xbd, 0xca, 0x6a, 0x32, 0x78, 0xf4, 0xfd, 0xaf, 0x7f, 0xfc, 0xd8, 0xd9,
	0x46, 0x28, 0x38, 0xbd, 0x15, 0xcc, 0xcc, 0xed, 0x81, 0x34, 0x77, 0x26, 0x30, 0xb0, 0xd9, 0x6a,
	0x24, 0x68, 0xd4, 0xbc, 0xa8, 0x3e, 0xa7, 0x7f, 0x20, 0xc1, 0x9a, 0x64, 0x07, 0x8d, 0x2e, 0x93,
	0x04, 0xdf, 0xea, 0xd1, 0x7c, 0x87, 0x3e, 0x82, 0x57, 0x6b, 0x64, 0x47, 0xb2, 0xa4, 0x24, 0x7b,
	0x2e, 0xe5, 0x55, 0xee, 0xbf, 0xe9, 0xa0, 0x63, 0xe8, 0x5b, 0xf7, 0xa1, 0x56, 0x51, 0xcd, 0x07,
	0x31, 0x7a, 0xf3, 0x19, 0xe8, 0xf3, 0x84, 0x89, 0x74, 0x12, 0x9a, 0x59, 0x97, 0xda, 0x31, 0x5f,
	0x22, 0x6a, 0x78, 0xec, 0x12, 0x51, 0xd3, 0x1b, 0xf8, 0x0d, 0x4d, 0xf4, 0x1a, 0xda, 0x6a, 0x10,
	0x99, 0xa4, 0x83, 0xc9, 0x2f, 0xe7, 0xbe, 0xf3, 0xe4, 0xdc, 0x77, 0x7e, 0x3f, 0xf7, 0x9d, 0x1f,
	0x2e, 0xfc, 0x95, 0x27, 0x17, 0xfe, 0xca, 0xd3, 0x0b, 0x7f, 0xe5, 0xe1, 0x8d, 0x22, 0x1b, 0xcb,
	0xe8, 0xe4, 0x6c, 0x1c, 0xf1, 0x6c, 0x4c, 0xe6, 0x81, 0xe0, 0xf3, 0x32, 0xa2, 0x46, 0xd5, 0x52,
	0xff, 0x5f, 0x14, 0xc7, 0x81, 0x66, 0x3c, 0x5e, 0xd5, 0x7f, 0x14, 0xef, 0xff, 0x1d, 0x00, 0x00,
	0xff, 0xff, 0x12, 0xba, 0xcc, 0xe3, 0x98, 0x08, 0x00, 0x00,
}

func (m *Tick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tick) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tick) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Open != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Open))))
		i--
		dAtA[i] = 0x5d
	}
	if m.ClosePriceChange24H != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ClosePriceChange24H))))
		i--
		dAtA[i] = 0x55
	}
	if m.Lowest24H != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Lowest24H))))
		i--
		dAtA[i] = 0x4d
	}
	if m.Highest24H != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Highest24H))))
		i--
		dAtA[i] = 0x45
	}
	if m.Volume24H != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Volume24H))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Timestamp != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Timestamp))))
		i--
		dAtA[i] = 0x35
	}
	if m.Last != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Last))))
		i--
		dAtA[i] = 0x2d
	}
	if m.BestAsk != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BestAsk))))
		i--
		dAtA[i] = 0x25
	}
	if m.BestBid != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BestBid))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OHLCV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OHLCV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OHLCV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x40
	}
	if m.Volume != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Volume))
		i--
		dAtA[i] = 0x38
	}
	if m.Close != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Close))))
		i--
		dAtA[i] = 0x35
	}
	if m.Low != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Low))))
		i--
		dAtA[i] = 0x2d
	}
	if m.High != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.High))))
		i--
		dAtA[i] = 0x25
	}
	if m.Open != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Open))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trade) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x38
	}
	if m.Units != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Units))))
		i--
		dAtA[i] = 0x35
	}
	if m.Amount != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Amount))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Direction != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TradeID) > 0 {
		i -= len(m.TradeID)
		copy(dAtA[i:], m.TradeID)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.TradeID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Depth != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TicksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TicksResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TicksResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ticks) > 0 {
		for iNdEx := len(m.Ticks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ticks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTicks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TradesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTicks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CandlesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Depth != 0 {
		i = encodeVarintTicks(dAtA, i, uint64(m.Depth))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Interval) > 0 {
		i -= len(m.Interval)
		copy(dAtA[i:], m.Interval)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Interval)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandlesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandlesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandlesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTicks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Since) > 0 {
		i -= len(m.Since)
		copy(dAtA[i:], m.Since)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Since)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompareRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompareRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interval) > 0 {
		i -= len(m.Interval)
		copy(dAtA[i:], m.Interval)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Interval)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Instrument) > 0 {
		i -= len(m.Instrument)
		copy(dAtA[i:], m.Instrument)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Instrument)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Market) > 0 {
		i -= len(m.Market)
		copy(dAtA[i:], m.Market)
		i = encodeVarintTicks(dAtA, i, uint64(len(m.Market)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompareResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompareResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Difference != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Difference))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func encodeVarintTicks(dAtA []byte, offset int, v uint64) int {
	offset -= sovTicks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Tick) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	if m.BestBid != 0 {
		n += 5
	}
	if m.BestAsk != 0 {
		n += 5
	}
	if m.Last != 0 {
		n += 5
	}
	if m.Timestamp != 0 {
		n += 5
	}
	if m.Volume24H != 0 {
		n += 5
	}
	if m.Highest24H != 0 {
		n += 5
	}
	if m.Lowest24H != 0 {
		n += 5
	}
	if m.ClosePriceChange24H != 0 {
		n += 5
	}
	if m.Open != 0 {
		n += 5
	}
	return n
}

func (m *OHLCV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	if m.Open != 0 {
		n += 5
	}
	if m.High != 0 {
		n += 5
	}
	if m.Low != 0 {
		n += 5
	}
	if m.Close != 0 {
		n += 5
	}
	if m.Volume != 0 {
		n += 1 + sovTicks(uint64(m.Volume))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTicks(uint64(m.Timestamp))
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.TradeID)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovTicks(uint64(m.Direction))
	}
	if m.Amount != 0 {
		n += 5
	}
	if m.Units != 0 {
		n += 5
	}
	if m.Timestamp != 0 {
		n += 1 + sovTicks(uint64(m.Timestamp))
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	if m.Depth != 0 {
		n += 1 + sovTicks(uint64(m.Depth))
	}
	return n
}

func (m *TicksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ticks) > 0 {
		for _, e := range m.Ticks {
			l = e.Size()
			n += 1 + l + sovTicks(uint64(l))
		}
	}
	return n
}

func (m *TradesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTicks(uint64(l))
		}
	}
	return n
}

func (m *CandlesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	if m.Depth != 0 {
		n += 1 + sovTicks(uint64(m.Depth))
	}
	return n
}

func (m *CandlesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTicks(uint64(l))
		}
	}
	return n
}

func (m *RangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Since)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	return n
}

func (m *CompareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Market)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Instrument)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	l = len(m.Interval)
	if l > 0 {
		n += 1 + l + sovTicks(uint64(l))
	}
	return n
}

func (m *CompareResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Difference != 0 {
		n += 5
	}
	return n
}

func sovTicks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTicks(x uint64) (n int) {
	return sovTicks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestBid", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BestBid = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BestAsk", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BestAsk = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Last = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Timestamp = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume24H", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Volume24H = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Highest24H", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Highest24H = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lowest24H", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Lowest24H = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosePriceChange24H", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ClosePriceChange24H = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Open = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OHLCV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OHLCV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OHLCV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Open = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.High = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Low = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Close = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Volume |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= TradeDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Amount = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Units", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Units = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TicksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TicksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TicksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticks = append(m.Ticks, &Tick{})
			if err := m.Ticks[len(m.Ticks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Trade{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			m.Depth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Depth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandlesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandlesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandlesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &OHLCV{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Since = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Market", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Market = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instrument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instrument = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTicks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTicks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interval = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difference", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Difference = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTicks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTicks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTicks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTicks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTicks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTicks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTicks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTicks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTicks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTicks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTicks = fmt.Errorf("proto: unexpected end of group")
)
